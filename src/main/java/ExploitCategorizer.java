import com.sun.xml.internal.ws.util.StringUtils;
import core.Categoriser;
import core.Parser;
import core.data.Categories;
import static core.Parser.DATA;
import java.util.*;

/*
    Now with comments!
 */

@SuppressWarnings("SpellCheckingInspection")
public class ExploitCategorizer {

    private static void help() {
        System.out.print("[Using the arguments]\n- When using EC the following arguments are required.\n  \n  [The amount of pages to be searched, remember a high number will take longer to load]\n  \"?pages:#\"\n\n  [The query to be referenced in categories, note: if you would like to use mulitple words you must seperate them with a double ampersand symbol.]\n  \"?query:#\"\n\n- Once you are brought to the categories found with your query referenced you can view them by typing... \n  \n  [*] being either key words from their title or just the title itself.\n  \"?ls:%s\" \n\n   e.g. \"?ls:denial\" will open the Denial of Service category.\n\n\n[Adding your own data and/or categories]\n- Adding data and categories is simple, to add data to the pre-existing categories just add keywords to the category array of your picking, which can be found in the \"src/main/java/core/data/Categories.java\" file.\n\n- To add your very own category you need the reference data which can be created like so...\n\n    [Must be a string array as it is what the following method requests]\n    String[] Metasploit_Exploits_Category = {\n        \"metasploit\", \"meta\"\n    };\n\n- Now to add this data into the categoriser system we must use the following method anywhere before the Categoriser class is instantiated.\n\n    [The text between quotes being the category name]\n    Categories.AddCategory(Metasploit_Exploits_Category, \"Metasploit Exploits\");\n\n- And you're done! You should see your category appear on the next compile and may view it by following the same procedure as stated above.");
    }

    public static void main(String[] args) {
        // Give it a default value if the "?pages:" argument isn't specified.
        int pages_to_parse = 1;

        // Input scanner instantiation.
        Scanner in = new Scanner(System.in);

        // Default our query to null because this is a necessary field.
        String query = null;

        // Parse the arguments
        for(String arg : args) {

            // Sets the number of pages if this argument is featured.
            if(arg.contains("?pages:")) {
                pages_to_parse = Integer.parseInt(arg.substring(arg.indexOf(":") + 1, arg.length()));
            }

            // This will set the null query to whatever specufied and parse any && operators.
            if(arg.contains("?query:")) {
                query = arg.substring(arg.indexOf(":") + 1, arg.length()).toLowerCase();
                if(arg.contains("&&")) {
                    query = query.replaceAll("&&", " ");
                }
            }

            // Just the help function.
            if(arg.equals("?help")) {
                help();
            }
        }

        // Instantiate our parser class.
        Parser parser = new Parser(pages_to_parse);

        // Null check for query, just in case they didn't supply us with a query.
        if(query == null) {
            System.out.println("Error: no query supplied.");
            return;
        }

        // Demonstration of our custom category method.

        // Here we specify our data.
        String[] Metasploit_Exploits_Category = {
                "metasploit", "meta"
        };

        // Add our data to the category name, "Metasploit Exploits".
        Categories.AddCategory(Metasploit_Exploits_Category, "Metasploit Exploits");

        // Let the user know we are collecting the data from exploit-db as it will usually take 20-30 seconds depending on the pages being parsed.
        System.out.println("Collecting data from exploit-db...");

        // Here we put the data we collected from our parser into a list of strings.
        List<String> authors = new ArrayList<>(parser.Parse(DATA.AUTHORS));
        List<String> titles = new ArrayList<>(parser.Parse(DATA.TITLES));
        List<String> platforms = new ArrayList<>(parser.Parse(DATA.PLATFORMS));

        // Here is the count for the amount of times our query was referenced.
        int references = 0;

        // To make everything case-insensitive we set all of our data to a lowercase version of itself.
        authors.replaceAll(String::toLowerCase);
        titles.replaceAll(String::toLowerCase);
        platforms.replaceAll(String::toLowerCase);

        // Here we actually check for each reference and then we increment our reference count above.
        for(int r = 0; r < authors.size(); r++) {
            if(authors.get(r).contains(query) || titles.get(r).contains(query) || platforms.get(r).contains(query)) {
                references++;
            }
        }

        // We let the user know that we have finished parsing the data from exploit-db and we give them the total count of references we found.
        System.out.println("Found " + references + " possible references for \"" + query+ "\" found within " + pages_to_parse + " pages.");

        // Here we instantiate our categoriser.
        Categoriser sorter = new Categoriser(authors, titles, platforms, query);

        // We sort our categories reference information into a dictionary.
        Dictionary<String, List<String[]>> categories = sorter.Sort();

        // We let the user know that we found their reference in the following areas.
        System.out.println("\nReferences were located in following areas.");

        // To create an printf parsable string we need to generate one of our category data.
        // we start by instantiating a string builder and a count of the amount of categories we have.
        StringBuilder printfTemplate = new StringBuilder();
        int category_count = Categories.CategoryNames.size();

        // We then start building the parsable string.
        for(int x = 0; x < category_count; x++) {
            printfTemplate.append("[+] %s (%s)       ");

            // We want two categories on one line so we add a "\n" operator if it is an odd index.
            printfTemplate.append((x % 2 == 1) ? "\n" : "");
        }

        // We use the PrintCategories method to print our categories with the parsable string we generated.
        Categories.PrintCategories(printfTemplate.toString() + "\n", categories);

        // Here we parse our "?ls:%s" argument, we make the data lowercase and replace all the double ampersand operators with spaces.
        String categoricalQuery = in.nextLine().toLowerCase().replaceAll(" ", "").replaceAll("&&", " ");

        // Here we make it easier for the user so they don't need to type the entire category name into the argument.
        // We pair our category with a list all the words in its name, e.g. k->Denial of Service, v->(0): "Denial", (1): "of", (2): "Service".
        Dictionary<String, List<String>> keywords = new Hashtable<>();

        // Many categories may contain the keyword "of" or "exploits" so we need to remove them by iterating
        // though an array of common words and omitting them from our dictionary's value List<String>.
        for(int m = 0; m < Categories.CategoryNames.size(); m++) {

            // Our common words data.
            String[] common_words = {
                    "of", "exploits", "exploit"
            };

            // Here we split the category into singular words to stick into our dictionary's value List.
            String split_category_name = Categories.CategoryNames.get(m).toLowerCase();

            // For each of those singular words we omit the common words by replacing them with empty strings.
            for(String replacement : common_words) {
                split_category_name = split_category_name.replaceAll(replacement, "");
            }

            // We create our dictonary's value List using the main keywords we have filtered above.
            List<String> words = new ArrayList<>(Arrays.asList(split_category_name.split(" ")));

            // Finally we add them into the dictonary.
            keywords.put(Categories.CategoryNames.get(m), words);
        }

        // Now we check if the categorical query they entered matches any keywords and if it does we return the dictonary's list of multidimensional arrays which we print further down.
        for(int b = 0; b < category_count; b++) {

            // Has to contain ?ls: so we know what the user is asking for.
            if(categoricalQuery.contains("?ls:") && (keywords.get(Categories.CategoryNames.get(b)).contains(categoricalQuery.substring(categoricalQuery.indexOf(":") + 1, categoricalQuery.length()))
                || categoricalQuery.contains(Categories.CategoryNames.get(b))))
            {
                // Using our listSets method we print the content from the list of multidimensional arrays we recieved above.
                listSets(Categories.CategoryNames.get(b), categories);
            }
        }
    }

    private static void listSets(String key, Dictionary<String, List<String[]>> categories) {
        // For each array in the array we print it's data.
        for(int i = 0; i < categories.get(key).size(); i++) {
            System.out.printf("\nTitle: %s\nPlatform: %s\nAuthor: %s\n",

                    // We use the StringUtils capitalize method here as we have had to make the data lowercase to prevent
                    // case sensitivity, but it works well enough.
                    StringUtils.capitalize(categories.get(key).get(i)[0]),
                    StringUtils.capitalize(categories.get(key).get(i)[1]),
                    StringUtils.capitalize(categories.get(key).get(i)[2]));
        }
    }
}
